---
sidebar: 'auto'
title: 02回调函数callback
date: 2022.03.10
tags:
 - Async
categories: 
 - 09JS异步
---

# 回调函数callback

## 1.回调

回调函数意指异步事件完成后再回过头来调用的函数，在前面的例子中我们已经见识到了使用回调函数管理异步事件结果的例子。

\- 用一个例子比喻回调：我在写代码，然后告诉小明帮我拿一本书过来我要查一个问题，然后小明去拿书了，而我在他拿回来之前继续写代码，等他帮我把书拿回来之后我就开始查这本书。

此场景中我写代码就是主线程中正在执行的同步代码，告诉小明帮我拿书则是发出一个异步任务，小明去做了，然后我拿到这本书查的事件就是处理结果的回调函数了。类代码如下：

```js
写代码1;
小明拿书((书)=>{
    查书;
});
写代码2;
```

\- 此场景中写代码1与写代码2不会被小明拿书阻塞，而且小明拿过书来我就会执行查书的回调函数。

## 2.回调问题

\- 从代码字面上来看的执行顺序和实际的执行顺序不同。

\- 比如上面的，虽然我们从上到下写的顺序是：**写代码1->小明拿书查书->写代码2，**

但实际的执行顺序是：**写代码1->写代码2->小明拿书查书。**

\- 所以说掺杂了很多回调的代码其可读性是较差的，**我们并不能直观地看出该程序的运行顺序是怎样的**。尤其是出现了经典的回调地狱（回调函数嵌套的情况）时：

```js
fn1(function callbackA(){
    fn2(function callbackB(){
        fn3(function callbackC(){
            ......
        });
    });
});
```

## 3.信任问题

\- 再翻上去看一看让小明拿书的例子。在该例子中我一直干的事情是写代码，然后交代小明拿书这里请注意，执行任务的主人公已经发生变化——是小明去拿书了，然后我以一个参数的形式丢给异步方法一个处理结果的回调，小明把书给我时执行这个查书回调。

\- 在这个场景中的异步事件上我已经把**控制权转移给了的第三方（小明），这种情况叫控制反转**，这回导致一系列的不信任问题：(书)=>{查书;}此回调函数会在结果返回时被调用几次？我能相信他会及时调用吗？他是否会早调用？，**也就是说，结果返回的时机由环境监控，但是如何利用此时机则是由第三方决定的。**

\- 我们经常会调用第三方的异步方法，而对于此第三方我们可以完全信任他会正确触发我们的回调吗？——这就是回调的信任问题。而我们要解决这个信任问题就还需要插入很多更难维护的代码。比如说上面我要防止多次调用查书的回调就会加一个锁：

```js
var flag = false;
小明拿书((书)=>{
    if(!flag) {
        查书;
        flag = true;
    } else return;
});
```

























































































































































